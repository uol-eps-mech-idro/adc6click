<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>adc6click.ad7124.ad7124driver API documentation</title>
<meta name="description" content="AD7124-8 driver.
Provides functions to read and write to any register and to configure
the AD7124." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>adc6click.ad7124.ad7124driver</code></h1>
</header>
<section id="section-intro">
<p>AD7124-8 driver.
Provides functions to read and write to any register and to configure
the AD7124.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34; AD7124-8 driver.
Provides functions to read and write to any register and to configure
the AD7124.
&#34;&#34;&#34;

import time
from ad7124.ad7124spi import AD7124SPI  # , bytes_to_string
from ad7124.ad7124registers import AD7124RegNames, AD7124Registers


class AD7124Driver:
    &#34;&#34;&#34; Provides a wrapper that hides the messy parts of the AD7124
    implementation.
    &#34;&#34;&#34;

    def __init__(self, position):
        &#34;&#34;&#34; Initialise the AD7124 device. &#34;&#34;&#34;
        self._registers = AD7124Registers()
        self._spi = AD7124SPI(position)
        self.reset()
        # Check correct device is present.
        ad7124_id = self.read_id()
        # print(&#34;init id&#34;, hex(ad7124_id))
        if ad7124_id not in (0x14, 0x16):
            raise OSError(&#34;ERROR: device on SPI bus is NOT an AD7124!&#34;)

    def _build_command(self, register_enum, read=False):
        &#34;&#34;&#34; Builds a command byte.
        First bit (bit 7) must be a 0.
        Second bit (bit 6) is read (1) or write (0).
        Remaining 6 bits are register address.
        &#34;&#34;&#34;
        command = 0
        if read:
            command += 1 &lt;&lt; 6
        command += register_enum.value &amp; 0x3F
        # print(&#34;_build_command&#34;, hex(command))
        return command

    def _read_register(self, register_enum, status_byte):
        &#34;&#34;&#34; Returns the value read from the register as a tuple of:
        count and a list of bytes.
        &#34;&#34;&#34;
        to_send = []
        command = self._build_command(register_enum, True)
        to_send.append(command)
        # Send correct number of padding bytes to get result.
        num_bytes = self._registers.size(register_enum)
        if status_byte:
            num_bytes += 1
        value = 0
        value_bytes = value.to_bytes(num_bytes, byteorder=&#34;big&#34;)
        to_send += value_bytes
        (count, result) = self._spi.read_register(to_send)
        # print(&#34;_read_register: count&#34;, count, &#34;data&#34;, result)
        return result

    def _data_to_int(_, data):
        int_value = 0
        # Remove first byte as always 0xFF
        data = data[1:]
        for byte_value in data:
            int_value &lt;&lt;= 8
            int_value |= byte_value
        return int_value

    def reset(self):
        &#34;&#34;&#34; Resets the AD7124 to power up conditions. &#34;&#34;&#34;
        to_send = b&#34;\xff\xff\xff\xff\xff\xff\xff\xff&#34;
        # print(&#34;reset command&#34;, to_send)
        self._spi.write_register(to_send)
        # TODO WAIT UNTIL PROPERLY READY
        time.sleep(0.001)
        # Disable Channel 0 (enabled by default after reset).
        # 0x0001 is default for the other channel registers.
        self.write_register(AD7124RegNames.CH0_MAP_REG, 0x0001)

    def read_id(self):
        &#34;&#34;&#34; The value of the ID register is returned.
        :returns: The value of the ID register.  Should be 0x14 or 0x16.
        &#34;&#34;&#34;
        # print(&#34;read_id&#34;)
        register_enum = AD7124RegNames(AD7124RegNames.ID_REG)
        result = self.read_register(register_enum)
        return result

    def write_register(self, register_enum, value):
        &#34;&#34;&#34; Write the given value to the given register.
        Args:
            register_enum: The register to write to,
                e.g. AD7124RegNames.ERREN_REG.
            value: The value as an integer.
        &#34;&#34;&#34;
        # Command value
        to_send = []
        command = self._build_command(register_enum)
        to_send.append(command)
        # Convert value to bytes.
        num_bytes = self._registers.size(register_enum)
        value_bytes = value.to_bytes(num_bytes, byteorder=&#34;big&#34;)
        to_send += value_bytes
        # Print to_send as hex values for easier debugging.
        # print(&#34;write_register: to_send&#34;, bytes_to_string(to_send))
        # Write the data.
        self._spi.write_register(to_send)

    def read_register(self, register_enum):
        &#34;&#34;&#34; Returns the value read from the register as an int value.
        Args:
            register_enum: The register to read,
                e.g. AD7124RegNames.DATA.
        Returns:
            An integer value of the register contents.
        &#34;&#34;&#34;
        result = self._read_register(register_enum, False)
        value = self._data_to_int(result)
        # print(&#34;read_register: value&#34;, hex(value))
        return value

    def read_status(self):
        &#34;&#34;&#34; Returns the value of the status register as a tuple.
        Returns:
            A tuple containing the values:
            (ready{bool}, error{bool}, power on reset{bool}, active channel)
        NOTE: ready = True when ready.  The ADC sets bit 7 to low when ready
        so this code inverts the sense to make it behave as the other flags do.
        &#34;&#34;&#34;
        # RDY is inverted.
        ready = True
        error = False
        power_on_reset = False
        active_channel = 0
        value = self.read_register(AD7124RegNames.STATUS_REG)
        # print(&#34;read_status&#34;, hex(value))
        if value &amp; 0x80:
            ready = False
            # print(&#34;read_status: ready&#34;, ready)
        if value &amp; 0x40:
            error = True
            # print(&#34;read_status: error&#34;, error)
        if value &amp; 0x10:
            power_on_reset = True
            # print(&#34;read_status: power_on_reset&#34;, power_on_reset)
        active_channel &amp;= 0x0F
        return (ready, error, power_on_reset, active_channel)

    def read_register_with_status(self, register_enum):
        &#34;&#34;&#34; Read the given register returning value and status.

        NOTE: This function should only be used when the DATA_STATUS
        bit of the ADC_CONTROL register is set.
        Args:
            register_enum: The register to read,
                e.g. AD7124RegNames.DATA.
        Returns:
            A tuple of the value read from the register as an
            int value and the value of the status register.
        &#34;&#34;&#34;
        result = self._read_register(register_enum, True)
        # Status byte is the last byte.
        value = self._data_to_int(result[:-1])
        status = result[-1]
        print(
            &#34;read_register_with_status: value:&#34;,
            hex(value),
            &#34;status: &#34;,
            hex(status),
        )
        return (value, status)

    def read_data_wait(self):
        &#34;&#34;&#34; Waits for the data register to contain new data and then reads it.
        Returns:
            Tuple containing channel_number and the raw value.
        &#34;&#34;&#34;
        channel_number = -1
        int_value = 0
        start_time = time.time()
        while True:
            (ready, error, _, channel_number) = self.read_status()
            if ready and error == 0:
                int_value = self.read_register(AD7124RegNames.DATA_REG)
                # print(&#34;rdw: int_value, channel&#34;, hex(int_value),
                #       channel_number)
                break
            else:
                if time.time() &gt; (start_time + 1):
                    # Break out of loop if stuck.
                    # print(&#34;rdw: loop exit&#34;)
                    break
        return (channel_number, int_value)

    def set_channel(self, register_enum, enable, setup, ainp, ainm):
        &#34;&#34;&#34; Sets the given channel register using the given values.
        Args:
            register_enum: The register to set,
                e.g. AD7124RegNames.CH0_MAP_REG.
            enable: True to enable the channel.
            setup: Number of the setup to use.
            ainp: Positive input to use.
            ainm: Negative input to use.
        &#34;&#34;&#34;
        # The channel registers are 16 bits, MSB first.
        value = 0
        # bit 15
        if enable:
            value |= 0x8000
        # print(&#34;set_channel_register value:&#34;, hex(value))
        # bits 14:12
        value |= (setup &amp; 0x07) &lt;&lt; 12
        # print(&#34;set_channel_register value:&#34;, hex(value))
        # bits 9:5
        value |= (ainp &amp; 0x1F) &lt;&lt; 5
        # print(&#34;set_channel_register ainp:&#34;, hex(ainp))
        # print(&#34;set_channel_register value:&#34;, hex(value))
        # bits 4:0
        value |= ainm &amp; 0x1F
        # print(&#34;set_channel_register value:&#34;, hex(value))
        # Write to the register
        self.write_register(register_enum, value)

    def set_setup_config(
        self,
        register_enum,
        bipolar=True,
        burnout=0,
        ref_buf_p=False,
        ref_buf_m=False,
        ain_buf_p=True,
        ain_buf_m=True,
        ref_sel=0,
        pga=0,
    ):
        &#34;&#34;&#34; Sets the config register for the setup.
        See datasheet for description of what the parameters do.
        &#34;&#34;&#34;
        # The configuration registers are 24 bits, MSB first.
        # bits 15:12 must be 0.
        value = 0
        if bipolar:
            value |= 0x0800
        value |= (burnout &amp; 0x03) &lt;&lt; 9
        if ref_buf_p:
            value |= 0x0100
        if ref_buf_m:
            value |= 0x0080
        if ain_buf_p:
            value |= 0x0040
        if ain_buf_m:
            value |= 0x0020
        value |= (ref_sel &amp; 0x03) &lt;&lt; 3
        value |= pga &amp; 0x07
        # print(&#34;set_config_register value:&#34;, hex(value))
        self.write_register(register_enum, value)

    def set_setup_filter(
        self,
        register_enum,
        filter_type=0,
        rej60=False,
        post_filter=6,
        single_cycle=False,
        output_data_rate=0x180,
    ):
        &#34;&#34;&#34; Sets the filter register for the setup.
        See datasheet for description of what the parameters do.
        &#34;&#34;&#34;
        # The filter registers are 24 bits, MSB first.
        # bits 15:11 must be 0.
        value = 0
        value |= (filter_type &amp; 0x07) &lt;&lt; 21
        if rej60:
            value |= 0x100000
        value |= (post_filter &amp; 0x07) &lt;&lt; 17
        if single_cycle:
            value |= 0x010000
        value |= output_data_rate &amp; 0x7FF
        # print(&#34;set_filter_register value:&#34;, hex(value))
        self.write_register(register_enum, value)

    def set_setup_offset(self, register_enum, new_offset):
        &#34;&#34;&#34; Sets the offset register for the setup.
        See datasheet for description of what the parameters do.
        &#34;&#34;&#34;
        # The offset registers are 24 bits, MSB first.
        value = 0
        value |= new_offset &amp; 0xFFFFFF
        # print(&#34;set_setup_offset value:&#34;, hex(value))
        self.write_register(register_enum, value)

    def set_setup_gain(self, register_enum, new_gain):
        &#34;&#34;&#34; Sets the gain register for the setup.
        See datasheet for description of what the parameters do.
        &#34;&#34;&#34;
        # The gain registers are 24 bits, MSB first.
        value = 0
        value |= new_gain &amp; 0xFFFFFF
        # print(&#34;set_gain_register value:&#34;, hex(value))
        self.write_register(register_enum, value)

    def set_adc_control(
        self,
        dout_rdy_del=False,
        cont_read=False,
        data_status=False,
        not_cs_en=False,
        ref_en=False,
        power_mode=0,
        mode=0,
        clock_select=0,
    ):
        &#34;&#34;&#34; Writes to the ADC control register.
        See datasheet for description of what the values do.
        &#34;&#34;&#34;
        value = 0
        # The control register is 16 bits, MSB first.
        # Bits 15:13 must be 0.
        if dout_rdy_del:
            value |= 0x1000
        if cont_read:
            value |= 0x0800
        if data_status:
            value |= 0x0400
        if not_cs_en:
            value |= 0x0200
        if ref_en:
            value |= 0x0100
        value |= (power_mode &amp; 0x03) &lt;&lt; 6
        value |= (mode &amp; 0x0F) &lt;&lt; 2
        value |= clock_select &amp; 0x03
        # print(&#34;set_control_register value:&#34;, hex(value))
        self.write_register(AD7124RegNames.ADC_CTRL_REG, value)

    def to_voltage(_, int_value, gain, vref, bipolar, scale):
        &#34;&#34;&#34; Converts integer value to a voltage.
        Args:
            int_value: the value to convert.
            gain: The PGA gain value, 1 to 128.
            vref: The reference voltage, normally +1.25V or +2.5V.
            bipolar: True for bipolar, else unipolar.
            scale: A scaling factor used for external potential division.
        The conversion specified in the datasheet (p.48) is:
        ```
        Unipolar:
            code = (2^N x AIN x Gain) / VRef
            Differential voltage: 0 = 0x000000, midscale = 0x80000,
                fullscale = 0xffffff
        Bipolar:
            code = 2^N-1 x [(AIN x Gain / VRef) + 1]
            Differential voltage: negative fullscale = 0x000000,
                0V = 0x80000, positive fullscale = 0xffffff
        where:
            N = 24
            AIN is the analogue input voltage.
            Gain is the gain setting (1 to 128).
        ```
        &#34;&#34;&#34;
        voltage = float(int_value)
        if bipolar:
            # Subtract 1
            voltage -= float(1)
            # Divide by 2^23
            voltage /= float(0x7FFFFF)
        else:
            # Divide by 2^24
            voltage /= float(0xFFFFFF)
        voltage *= float(vref)
        voltage /= float(gain)
        # Apply scaling factor to compensate for external resistor network.
        voltage *= float(scale)
        return voltage

    def to_temperature(_, int_value):
        &#34;&#34;&#34; Converts the given ADC value to temperature in degrees Celcius.
        &#34;&#34;&#34;
        # This is the formula in the data sheet but it doesn&#39;t work!
        temperature_c = (float(int_value - 0x800000) / 13584) - 272.5
        # Gives the result of -246.1C when room temperature is 23.0C.
        # Also goes negative when finger applied to device (should warm up).
        # temperature_c = float(int_value - 0x800000) / 13584
        return temperature_c

    # def set_error_register(self, value):
    #     &#34;&#34;&#34; Set the ERROR_EN register.
    #     :param value: The value to set (24 bits).
    #     &#34;&#34;&#34;
    #     self._spi.write_register(AD7124RegNames.ERREN_REG, value)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver"><code class="flex name class">
<span>class <span class="ident">AD7124Driver</span></span>
<span>(</span><span>position)</span>
</code></dt>
<dd>
<section class="desc"><p>Provides a wrapper that hides the messy parts of the AD7124
implementation.</p>
<p>Initialise the AD7124 device.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AD7124Driver:
    &#34;&#34;&#34; Provides a wrapper that hides the messy parts of the AD7124
    implementation.
    &#34;&#34;&#34;

    def __init__(self, position):
        &#34;&#34;&#34; Initialise the AD7124 device. &#34;&#34;&#34;
        self._registers = AD7124Registers()
        self._spi = AD7124SPI(position)
        self.reset()
        # Check correct device is present.
        ad7124_id = self.read_id()
        # print(&#34;init id&#34;, hex(ad7124_id))
        if ad7124_id not in (0x14, 0x16):
            raise OSError(&#34;ERROR: device on SPI bus is NOT an AD7124!&#34;)

    def _build_command(self, register_enum, read=False):
        &#34;&#34;&#34; Builds a command byte.
        First bit (bit 7) must be a 0.
        Second bit (bit 6) is read (1) or write (0).
        Remaining 6 bits are register address.
        &#34;&#34;&#34;
        command = 0
        if read:
            command += 1 &lt;&lt; 6
        command += register_enum.value &amp; 0x3F
        # print(&#34;_build_command&#34;, hex(command))
        return command

    def _read_register(self, register_enum, status_byte):
        &#34;&#34;&#34; Returns the value read from the register as a tuple of:
        count and a list of bytes.
        &#34;&#34;&#34;
        to_send = []
        command = self._build_command(register_enum, True)
        to_send.append(command)
        # Send correct number of padding bytes to get result.
        num_bytes = self._registers.size(register_enum)
        if status_byte:
            num_bytes += 1
        value = 0
        value_bytes = value.to_bytes(num_bytes, byteorder=&#34;big&#34;)
        to_send += value_bytes
        (count, result) = self._spi.read_register(to_send)
        # print(&#34;_read_register: count&#34;, count, &#34;data&#34;, result)
        return result

    def _data_to_int(_, data):
        int_value = 0
        # Remove first byte as always 0xFF
        data = data[1:]
        for byte_value in data:
            int_value &lt;&lt;= 8
            int_value |= byte_value
        return int_value

    def reset(self):
        &#34;&#34;&#34; Resets the AD7124 to power up conditions. &#34;&#34;&#34;
        to_send = b&#34;\xff\xff\xff\xff\xff\xff\xff\xff&#34;
        # print(&#34;reset command&#34;, to_send)
        self._spi.write_register(to_send)
        # TODO WAIT UNTIL PROPERLY READY
        time.sleep(0.001)
        # Disable Channel 0 (enabled by default after reset).
        # 0x0001 is default for the other channel registers.
        self.write_register(AD7124RegNames.CH0_MAP_REG, 0x0001)

    def read_id(self):
        &#34;&#34;&#34; The value of the ID register is returned.
        :returns: The value of the ID register.  Should be 0x14 or 0x16.
        &#34;&#34;&#34;
        # print(&#34;read_id&#34;)
        register_enum = AD7124RegNames(AD7124RegNames.ID_REG)
        result = self.read_register(register_enum)
        return result

    def write_register(self, register_enum, value):
        &#34;&#34;&#34; Write the given value to the given register.
        Args:
            register_enum: The register to write to,
                e.g. AD7124RegNames.ERREN_REG.
            value: The value as an integer.
        &#34;&#34;&#34;
        # Command value
        to_send = []
        command = self._build_command(register_enum)
        to_send.append(command)
        # Convert value to bytes.
        num_bytes = self._registers.size(register_enum)
        value_bytes = value.to_bytes(num_bytes, byteorder=&#34;big&#34;)
        to_send += value_bytes
        # Print to_send as hex values for easier debugging.
        # print(&#34;write_register: to_send&#34;, bytes_to_string(to_send))
        # Write the data.
        self._spi.write_register(to_send)

    def read_register(self, register_enum):
        &#34;&#34;&#34; Returns the value read from the register as an int value.
        Args:
            register_enum: The register to read,
                e.g. AD7124RegNames.DATA.
        Returns:
            An integer value of the register contents.
        &#34;&#34;&#34;
        result = self._read_register(register_enum, False)
        value = self._data_to_int(result)
        # print(&#34;read_register: value&#34;, hex(value))
        return value

    def read_status(self):
        &#34;&#34;&#34; Returns the value of the status register as a tuple.
        Returns:
            A tuple containing the values:
            (ready{bool}, error{bool}, power on reset{bool}, active channel)
        NOTE: ready = True when ready.  The ADC sets bit 7 to low when ready
        so this code inverts the sense to make it behave as the other flags do.
        &#34;&#34;&#34;
        # RDY is inverted.
        ready = True
        error = False
        power_on_reset = False
        active_channel = 0
        value = self.read_register(AD7124RegNames.STATUS_REG)
        # print(&#34;read_status&#34;, hex(value))
        if value &amp; 0x80:
            ready = False
            # print(&#34;read_status: ready&#34;, ready)
        if value &amp; 0x40:
            error = True
            # print(&#34;read_status: error&#34;, error)
        if value &amp; 0x10:
            power_on_reset = True
            # print(&#34;read_status: power_on_reset&#34;, power_on_reset)
        active_channel &amp;= 0x0F
        return (ready, error, power_on_reset, active_channel)

    def read_register_with_status(self, register_enum):
        &#34;&#34;&#34; Read the given register returning value and status.

        NOTE: This function should only be used when the DATA_STATUS
        bit of the ADC_CONTROL register is set.
        Args:
            register_enum: The register to read,
                e.g. AD7124RegNames.DATA.
        Returns:
            A tuple of the value read from the register as an
            int value and the value of the status register.
        &#34;&#34;&#34;
        result = self._read_register(register_enum, True)
        # Status byte is the last byte.
        value = self._data_to_int(result[:-1])
        status = result[-1]
        print(
            &#34;read_register_with_status: value:&#34;,
            hex(value),
            &#34;status: &#34;,
            hex(status),
        )
        return (value, status)

    def read_data_wait(self):
        &#34;&#34;&#34; Waits for the data register to contain new data and then reads it.
        Returns:
            Tuple containing channel_number and the raw value.
        &#34;&#34;&#34;
        channel_number = -1
        int_value = 0
        start_time = time.time()
        while True:
            (ready, error, _, channel_number) = self.read_status()
            if ready and error == 0:
                int_value = self.read_register(AD7124RegNames.DATA_REG)
                # print(&#34;rdw: int_value, channel&#34;, hex(int_value),
                #       channel_number)
                break
            else:
                if time.time() &gt; (start_time + 1):
                    # Break out of loop if stuck.
                    # print(&#34;rdw: loop exit&#34;)
                    break
        return (channel_number, int_value)

    def set_channel(self, register_enum, enable, setup, ainp, ainm):
        &#34;&#34;&#34; Sets the given channel register using the given values.
        Args:
            register_enum: The register to set,
                e.g. AD7124RegNames.CH0_MAP_REG.
            enable: True to enable the channel.
            setup: Number of the setup to use.
            ainp: Positive input to use.
            ainm: Negative input to use.
        &#34;&#34;&#34;
        # The channel registers are 16 bits, MSB first.
        value = 0
        # bit 15
        if enable:
            value |= 0x8000
        # print(&#34;set_channel_register value:&#34;, hex(value))
        # bits 14:12
        value |= (setup &amp; 0x07) &lt;&lt; 12
        # print(&#34;set_channel_register value:&#34;, hex(value))
        # bits 9:5
        value |= (ainp &amp; 0x1F) &lt;&lt; 5
        # print(&#34;set_channel_register ainp:&#34;, hex(ainp))
        # print(&#34;set_channel_register value:&#34;, hex(value))
        # bits 4:0
        value |= ainm &amp; 0x1F
        # print(&#34;set_channel_register value:&#34;, hex(value))
        # Write to the register
        self.write_register(register_enum, value)

    def set_setup_config(
        self,
        register_enum,
        bipolar=True,
        burnout=0,
        ref_buf_p=False,
        ref_buf_m=False,
        ain_buf_p=True,
        ain_buf_m=True,
        ref_sel=0,
        pga=0,
    ):
        &#34;&#34;&#34; Sets the config register for the setup.
        See datasheet for description of what the parameters do.
        &#34;&#34;&#34;
        # The configuration registers are 24 bits, MSB first.
        # bits 15:12 must be 0.
        value = 0
        if bipolar:
            value |= 0x0800
        value |= (burnout &amp; 0x03) &lt;&lt; 9
        if ref_buf_p:
            value |= 0x0100
        if ref_buf_m:
            value |= 0x0080
        if ain_buf_p:
            value |= 0x0040
        if ain_buf_m:
            value |= 0x0020
        value |= (ref_sel &amp; 0x03) &lt;&lt; 3
        value |= pga &amp; 0x07
        # print(&#34;set_config_register value:&#34;, hex(value))
        self.write_register(register_enum, value)

    def set_setup_filter(
        self,
        register_enum,
        filter_type=0,
        rej60=False,
        post_filter=6,
        single_cycle=False,
        output_data_rate=0x180,
    ):
        &#34;&#34;&#34; Sets the filter register for the setup.
        See datasheet for description of what the parameters do.
        &#34;&#34;&#34;
        # The filter registers are 24 bits, MSB first.
        # bits 15:11 must be 0.
        value = 0
        value |= (filter_type &amp; 0x07) &lt;&lt; 21
        if rej60:
            value |= 0x100000
        value |= (post_filter &amp; 0x07) &lt;&lt; 17
        if single_cycle:
            value |= 0x010000
        value |= output_data_rate &amp; 0x7FF
        # print(&#34;set_filter_register value:&#34;, hex(value))
        self.write_register(register_enum, value)

    def set_setup_offset(self, register_enum, new_offset):
        &#34;&#34;&#34; Sets the offset register for the setup.
        See datasheet for description of what the parameters do.
        &#34;&#34;&#34;
        # The offset registers are 24 bits, MSB first.
        value = 0
        value |= new_offset &amp; 0xFFFFFF
        # print(&#34;set_setup_offset value:&#34;, hex(value))
        self.write_register(register_enum, value)

    def set_setup_gain(self, register_enum, new_gain):
        &#34;&#34;&#34; Sets the gain register for the setup.
        See datasheet for description of what the parameters do.
        &#34;&#34;&#34;
        # The gain registers are 24 bits, MSB first.
        value = 0
        value |= new_gain &amp; 0xFFFFFF
        # print(&#34;set_gain_register value:&#34;, hex(value))
        self.write_register(register_enum, value)

    def set_adc_control(
        self,
        dout_rdy_del=False,
        cont_read=False,
        data_status=False,
        not_cs_en=False,
        ref_en=False,
        power_mode=0,
        mode=0,
        clock_select=0,
    ):
        &#34;&#34;&#34; Writes to the ADC control register.
        See datasheet for description of what the values do.
        &#34;&#34;&#34;
        value = 0
        # The control register is 16 bits, MSB first.
        # Bits 15:13 must be 0.
        if dout_rdy_del:
            value |= 0x1000
        if cont_read:
            value |= 0x0800
        if data_status:
            value |= 0x0400
        if not_cs_en:
            value |= 0x0200
        if ref_en:
            value |= 0x0100
        value |= (power_mode &amp; 0x03) &lt;&lt; 6
        value |= (mode &amp; 0x0F) &lt;&lt; 2
        value |= clock_select &amp; 0x03
        # print(&#34;set_control_register value:&#34;, hex(value))
        self.write_register(AD7124RegNames.ADC_CTRL_REG, value)

    def to_voltage(_, int_value, gain, vref, bipolar, scale):
        &#34;&#34;&#34; Converts integer value to a voltage.
        Args:
            int_value: the value to convert.
            gain: The PGA gain value, 1 to 128.
            vref: The reference voltage, normally +1.25V or +2.5V.
            bipolar: True for bipolar, else unipolar.
            scale: A scaling factor used for external potential division.
        The conversion specified in the datasheet (p.48) is:
        ```
        Unipolar:
            code = (2^N x AIN x Gain) / VRef
            Differential voltage: 0 = 0x000000, midscale = 0x80000,
                fullscale = 0xffffff
        Bipolar:
            code = 2^N-1 x [(AIN x Gain / VRef) + 1]
            Differential voltage: negative fullscale = 0x000000,
                0V = 0x80000, positive fullscale = 0xffffff
        where:
            N = 24
            AIN is the analogue input voltage.
            Gain is the gain setting (1 to 128).
        ```
        &#34;&#34;&#34;
        voltage = float(int_value)
        if bipolar:
            # Subtract 1
            voltage -= float(1)
            # Divide by 2^23
            voltage /= float(0x7FFFFF)
        else:
            # Divide by 2^24
            voltage /= float(0xFFFFFF)
        voltage *= float(vref)
        voltage /= float(gain)
        # Apply scaling factor to compensate for external resistor network.
        voltage *= float(scale)
        return voltage

    def to_temperature(_, int_value):
        &#34;&#34;&#34; Converts the given ADC value to temperature in degrees Celcius.
        &#34;&#34;&#34;
        # This is the formula in the data sheet but it doesn&#39;t work!
        temperature_c = (float(int_value - 0x800000) / 13584) - 272.5
        # Gives the result of -246.1C when room temperature is 23.0C.
        # Also goes negative when finger applied to device (should warm up).
        # temperature_c = float(int_value - 0x800000) / 13584
        return temperature_c</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.read_data_wait"><code class="name flex">
<span>def <span class="ident">read_data_wait</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Waits for the data register to contain new data and then reads it.</p>
<h2 id="returns">Returns</h2>
<p>Tuple containing channel_number and the raw value.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_data_wait(self):
    &#34;&#34;&#34; Waits for the data register to contain new data and then reads it.
    Returns:
        Tuple containing channel_number and the raw value.
    &#34;&#34;&#34;
    channel_number = -1
    int_value = 0
    start_time = time.time()
    while True:
        (ready, error, _, channel_number) = self.read_status()
        if ready and error == 0:
            int_value = self.read_register(AD7124RegNames.DATA_REG)
            # print(&#34;rdw: int_value, channel&#34;, hex(int_value),
            #       channel_number)
            break
        else:
            if time.time() &gt; (start_time + 1):
                # Break out of loop if stuck.
                # print(&#34;rdw: loop exit&#34;)
                break
    return (channel_number, int_value)</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.read_id"><code class="name flex">
<span>def <span class="ident">read_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>The value of the ID register is returned.
:returns: The value of the ID register.
Should be 0x14 or 0x16.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_id(self):
    &#34;&#34;&#34; The value of the ID register is returned.
    :returns: The value of the ID register.  Should be 0x14 or 0x16.
    &#34;&#34;&#34;
    # print(&#34;read_id&#34;)
    register_enum = AD7124RegNames(AD7124RegNames.ID_REG)
    result = self.read_register(register_enum)
    return result</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.read_register"><code class="name flex">
<span>def <span class="ident">read_register</span></span>(<span>self, register_enum)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the value read from the register as an int value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>register_enum</code></strong></dt>
<dd>The register to read,
e.g. AD7124RegNames.DATA.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An integer value of the register contents.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_register(self, register_enum):
    &#34;&#34;&#34; Returns the value read from the register as an int value.
    Args:
        register_enum: The register to read,
            e.g. AD7124RegNames.DATA.
    Returns:
        An integer value of the register contents.
    &#34;&#34;&#34;
    result = self._read_register(register_enum, False)
    value = self._data_to_int(result)
    # print(&#34;read_register: value&#34;, hex(value))
    return value</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.read_register_with_status"><code class="name flex">
<span>def <span class="ident">read_register_with_status</span></span>(<span>self, register_enum)</span>
</code></dt>
<dd>
<section class="desc"><p>Read the given register returning value and status.</p>
<p>NOTE: This function should only be used when the DATA_STATUS
bit of the ADC_CONTROL register is set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>register_enum</code></strong></dt>
<dd>The register to read,
e.g. AD7124RegNames.DATA.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <code>tuple</code> of <code>the</code> <code>value</code> <code>read</code> <code>from</code> <code>the</code> <code>register</code> <code>as</code> <code>an</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>int value and the value of the status register.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_register_with_status(self, register_enum):
    &#34;&#34;&#34; Read the given register returning value and status.

    NOTE: This function should only be used when the DATA_STATUS
    bit of the ADC_CONTROL register is set.
    Args:
        register_enum: The register to read,
            e.g. AD7124RegNames.DATA.
    Returns:
        A tuple of the value read from the register as an
        int value and the value of the status register.
    &#34;&#34;&#34;
    result = self._read_register(register_enum, True)
    # Status byte is the last byte.
    value = self._data_to_int(result[:-1])
    status = result[-1]
    print(
        &#34;read_register_with_status: value:&#34;,
        hex(value),
        &#34;status: &#34;,
        hex(status),
    )
    return (value, status)</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.read_status"><code class="name flex">
<span>def <span class="ident">read_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the value of the status register as a tuple.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A</code> <code>tuple</code> <code>containing</code> <code>the</code> <code>values</code>:</dt>
<dd>&nbsp;</dd>
<dt>(ready{bool}, error{bool}, power on reset{bool}, active channel)</dt>
<dt><strong><code>NOTE</code></strong> :&ensp;<code>ready</code> = <code>True</code> <code>when</code> <code>ready.</code>
<code>The</code> <code>ADC</code> <code>sets</code> <code>bit</code> <code>7</code> <code>to</code> <code>low</code> <code>when</code> <code>ready</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>so this code inverts the sense to make it behave as the other flags do.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_status(self):
    &#34;&#34;&#34; Returns the value of the status register as a tuple.
    Returns:
        A tuple containing the values:
        (ready{bool}, error{bool}, power on reset{bool}, active channel)
    NOTE: ready = True when ready.  The ADC sets bit 7 to low when ready
    so this code inverts the sense to make it behave as the other flags do.
    &#34;&#34;&#34;
    # RDY is inverted.
    ready = True
    error = False
    power_on_reset = False
    active_channel = 0
    value = self.read_register(AD7124RegNames.STATUS_REG)
    # print(&#34;read_status&#34;, hex(value))
    if value &amp; 0x80:
        ready = False
        # print(&#34;read_status: ready&#34;, ready)
    if value &amp; 0x40:
        error = True
        # print(&#34;read_status: error&#34;, error)
    if value &amp; 0x10:
        power_on_reset = True
        # print(&#34;read_status: power_on_reset&#34;, power_on_reset)
    active_channel &amp;= 0x0F
    return (ready, error, power_on_reset, active_channel)</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Resets the AD7124 to power up conditions.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34; Resets the AD7124 to power up conditions. &#34;&#34;&#34;
    to_send = b&#34;\xff\xff\xff\xff\xff\xff\xff\xff&#34;
    # print(&#34;reset command&#34;, to_send)
    self._spi.write_register(to_send)
    # TODO WAIT UNTIL PROPERLY READY
    time.sleep(0.001)
    # Disable Channel 0 (enabled by default after reset).
    # 0x0001 is default for the other channel registers.
    self.write_register(AD7124RegNames.CH0_MAP_REG, 0x0001)</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.set_adc_control"><code class="name flex">
<span>def <span class="ident">set_adc_control</span></span>(<span>self, dout_rdy_del=False, cont_read=False, data_status=False, not_cs_en=False, ref_en=False, power_mode=0, mode=0, clock_select=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Writes to the ADC control register.
See datasheet for description of what the values do.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_adc_control(
    self,
    dout_rdy_del=False,
    cont_read=False,
    data_status=False,
    not_cs_en=False,
    ref_en=False,
    power_mode=0,
    mode=0,
    clock_select=0,
):
    &#34;&#34;&#34; Writes to the ADC control register.
    See datasheet for description of what the values do.
    &#34;&#34;&#34;
    value = 0
    # The control register is 16 bits, MSB first.
    # Bits 15:13 must be 0.
    if dout_rdy_del:
        value |= 0x1000
    if cont_read:
        value |= 0x0800
    if data_status:
        value |= 0x0400
    if not_cs_en:
        value |= 0x0200
    if ref_en:
        value |= 0x0100
    value |= (power_mode &amp; 0x03) &lt;&lt; 6
    value |= (mode &amp; 0x0F) &lt;&lt; 2
    value |= clock_select &amp; 0x03
    # print(&#34;set_control_register value:&#34;, hex(value))
    self.write_register(AD7124RegNames.ADC_CTRL_REG, value)</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.set_channel"><code class="name flex">
<span>def <span class="ident">set_channel</span></span>(<span>self, register_enum, enable, setup, ainp, ainm)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the given channel register using the given values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>register_enum</code></strong></dt>
<dd>The register to set,
e.g. AD7124RegNames.CH0_MAP_REG.</dd>
<dt><strong><code>enable</code></strong></dt>
<dd>True to enable the channel.</dd>
<dt><strong><code>setup</code></strong></dt>
<dd>Number of the setup to use.</dd>
<dt><strong><code>ainp</code></strong></dt>
<dd>Positive input to use.</dd>
<dt><strong><code>ainm</code></strong></dt>
<dd>Negative input to use.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_channel(self, register_enum, enable, setup, ainp, ainm):
    &#34;&#34;&#34; Sets the given channel register using the given values.
    Args:
        register_enum: The register to set,
            e.g. AD7124RegNames.CH0_MAP_REG.
        enable: True to enable the channel.
        setup: Number of the setup to use.
        ainp: Positive input to use.
        ainm: Negative input to use.
    &#34;&#34;&#34;
    # The channel registers are 16 bits, MSB first.
    value = 0
    # bit 15
    if enable:
        value |= 0x8000
    # print(&#34;set_channel_register value:&#34;, hex(value))
    # bits 14:12
    value |= (setup &amp; 0x07) &lt;&lt; 12
    # print(&#34;set_channel_register value:&#34;, hex(value))
    # bits 9:5
    value |= (ainp &amp; 0x1F) &lt;&lt; 5
    # print(&#34;set_channel_register ainp:&#34;, hex(ainp))
    # print(&#34;set_channel_register value:&#34;, hex(value))
    # bits 4:0
    value |= ainm &amp; 0x1F
    # print(&#34;set_channel_register value:&#34;, hex(value))
    # Write to the register
    self.write_register(register_enum, value)</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_config"><code class="name flex">
<span>def <span class="ident">set_setup_config</span></span>(<span>self, register_enum, bipolar=True, burnout=0, ref_buf_p=False, ref_buf_m=False, ain_buf_p=True, ain_buf_m=True, ref_sel=0, pga=0)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the config register for the setup.
See datasheet for description of what the parameters do.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_setup_config(
    self,
    register_enum,
    bipolar=True,
    burnout=0,
    ref_buf_p=False,
    ref_buf_m=False,
    ain_buf_p=True,
    ain_buf_m=True,
    ref_sel=0,
    pga=0,
):
    &#34;&#34;&#34; Sets the config register for the setup.
    See datasheet for description of what the parameters do.
    &#34;&#34;&#34;
    # The configuration registers are 24 bits, MSB first.
    # bits 15:12 must be 0.
    value = 0
    if bipolar:
        value |= 0x0800
    value |= (burnout &amp; 0x03) &lt;&lt; 9
    if ref_buf_p:
        value |= 0x0100
    if ref_buf_m:
        value |= 0x0080
    if ain_buf_p:
        value |= 0x0040
    if ain_buf_m:
        value |= 0x0020
    value |= (ref_sel &amp; 0x03) &lt;&lt; 3
    value |= pga &amp; 0x07
    # print(&#34;set_config_register value:&#34;, hex(value))
    self.write_register(register_enum, value)</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_filter"><code class="name flex">
<span>def <span class="ident">set_setup_filter</span></span>(<span>self, register_enum, filter_type=0, rej60=False, post_filter=6, single_cycle=False, output_data_rate=384)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the filter register for the setup.
See datasheet for description of what the parameters do.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_setup_filter(
    self,
    register_enum,
    filter_type=0,
    rej60=False,
    post_filter=6,
    single_cycle=False,
    output_data_rate=0x180,
):
    &#34;&#34;&#34; Sets the filter register for the setup.
    See datasheet for description of what the parameters do.
    &#34;&#34;&#34;
    # The filter registers are 24 bits, MSB first.
    # bits 15:11 must be 0.
    value = 0
    value |= (filter_type &amp; 0x07) &lt;&lt; 21
    if rej60:
        value |= 0x100000
    value |= (post_filter &amp; 0x07) &lt;&lt; 17
    if single_cycle:
        value |= 0x010000
    value |= output_data_rate &amp; 0x7FF
    # print(&#34;set_filter_register value:&#34;, hex(value))
    self.write_register(register_enum, value)</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_gain"><code class="name flex">
<span>def <span class="ident">set_setup_gain</span></span>(<span>self, register_enum, new_gain)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the gain register for the setup.
See datasheet for description of what the parameters do.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_setup_gain(self, register_enum, new_gain):
    &#34;&#34;&#34; Sets the gain register for the setup.
    See datasheet for description of what the parameters do.
    &#34;&#34;&#34;
    # The gain registers are 24 bits, MSB first.
    value = 0
    value |= new_gain &amp; 0xFFFFFF
    # print(&#34;set_gain_register value:&#34;, hex(value))
    self.write_register(register_enum, value)</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_offset"><code class="name flex">
<span>def <span class="ident">set_setup_offset</span></span>(<span>self, register_enum, new_offset)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the offset register for the setup.
See datasheet for description of what the parameters do.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_setup_offset(self, register_enum, new_offset):
    &#34;&#34;&#34; Sets the offset register for the setup.
    See datasheet for description of what the parameters do.
    &#34;&#34;&#34;
    # The offset registers are 24 bits, MSB first.
    value = 0
    value |= new_offset &amp; 0xFFFFFF
    # print(&#34;set_setup_offset value:&#34;, hex(value))
    self.write_register(register_enum, value)</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.to_temperature"><code class="name flex">
<span>def <span class="ident">to_temperature</span></span>(<span>_, int_value)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts the given ADC value to temperature in degrees Celcius.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_temperature(_, int_value):
    &#34;&#34;&#34; Converts the given ADC value to temperature in degrees Celcius.
    &#34;&#34;&#34;
    # This is the formula in the data sheet but it doesn&#39;t work!
    temperature_c = (float(int_value - 0x800000) / 13584) - 272.5
    # Gives the result of -246.1C when room temperature is 23.0C.
    # Also goes negative when finger applied to device (should warm up).
    # temperature_c = float(int_value - 0x800000) / 13584
    return temperature_c</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.to_voltage"><code class="name flex">
<span>def <span class="ident">to_voltage</span></span>(<span>_, int_value, gain, vref, bipolar, scale)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts integer value to a voltage.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>int_value</code></strong></dt>
<dd>the value to convert.</dd>
<dt><strong><code>gain</code></strong></dt>
<dd>The PGA gain value, 1 to 128.</dd>
<dt><strong><code>vref</code></strong></dt>
<dd>The reference voltage, normally +1.25V or +2.5V.</dd>
<dt><strong><code>bipolar</code></strong></dt>
<dd>True for bipolar, else unipolar.</dd>
<dt><strong><code>scale</code></strong></dt>
<dd>A scaling factor used for external potential division.</dd>
</dl>
<p>The conversion specified in the datasheet (p.48) is:</p>
<pre><code>
Unipolar
-----
code = (2^N x AIN x Gain) / VRef
Differential voltage: 0 = 0x000000, midscale = 0x80000,
    fullscale = 0xffffff

Bipolar
-----
code = 2^N-1 x [(AIN x Gain / VRef) + 1]
Differential voltage: negative fullscale = 0x000000,
    0V = 0x80000, positive fullscale = 0xffffff
where:
    N = 24
    AIN is the analogue input voltage.
    Gain is the gain setting (1 to 128).
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_voltage(_, int_value, gain, vref, bipolar, scale):
    &#34;&#34;&#34; Converts integer value to a voltage.
    Args:
        int_value: the value to convert.
        gain: The PGA gain value, 1 to 128.
        vref: The reference voltage, normally +1.25V or +2.5V.
        bipolar: True for bipolar, else unipolar.
        scale: A scaling factor used for external potential division.
    The conversion specified in the datasheet (p.48) is:
    ```
    Unipolar:
        code = (2^N x AIN x Gain) / VRef
        Differential voltage: 0 = 0x000000, midscale = 0x80000,
            fullscale = 0xffffff
    Bipolar:
        code = 2^N-1 x [(AIN x Gain / VRef) + 1]
        Differential voltage: negative fullscale = 0x000000,
            0V = 0x80000, positive fullscale = 0xffffff
    where:
        N = 24
        AIN is the analogue input voltage.
        Gain is the gain setting (1 to 128).
    ```
    &#34;&#34;&#34;
    voltage = float(int_value)
    if bipolar:
        # Subtract 1
        voltage -= float(1)
        # Divide by 2^23
        voltage /= float(0x7FFFFF)
    else:
        # Divide by 2^24
        voltage /= float(0xFFFFFF)
    voltage *= float(vref)
    voltage /= float(gain)
    # Apply scaling factor to compensate for external resistor network.
    voltage *= float(scale)
    return voltage</code></pre>
</details>
</dd>
<dt id="adc6click.ad7124.ad7124driver.AD7124Driver.write_register"><code class="name flex">
<span>def <span class="ident">write_register</span></span>(<span>self, register_enum, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Write the given value to the given register.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>register_enum</code></strong></dt>
<dd>The register to write to,
e.g. AD7124RegNames.ERREN_REG.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>The value as an integer.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_register(self, register_enum, value):
    &#34;&#34;&#34; Write the given value to the given register.
    Args:
        register_enum: The register to write to,
            e.g. AD7124RegNames.ERREN_REG.
        value: The value as an integer.
    &#34;&#34;&#34;
    # Command value
    to_send = []
    command = self._build_command(register_enum)
    to_send.append(command)
    # Convert value to bytes.
    num_bytes = self._registers.size(register_enum)
    value_bytes = value.to_bytes(num_bytes, byteorder=&#34;big&#34;)
    to_send += value_bytes
    # Print to_send as hex values for easier debugging.
    # print(&#34;write_register: to_send&#34;, bytes_to_string(to_send))
    # Write the data.
    self._spi.write_register(to_send)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="adc6click.ad7124" href="index.html">adc6click.ad7124</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver" href="#adc6click.ad7124.ad7124driver.AD7124Driver">AD7124Driver</a></code></h4>
<ul class="">
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.read_data_wait" href="#adc6click.ad7124.ad7124driver.AD7124Driver.read_data_wait">read_data_wait</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.read_id" href="#adc6click.ad7124.ad7124driver.AD7124Driver.read_id">read_id</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.read_register" href="#adc6click.ad7124.ad7124driver.AD7124Driver.read_register">read_register</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.read_register_with_status" href="#adc6click.ad7124.ad7124driver.AD7124Driver.read_register_with_status">read_register_with_status</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.read_status" href="#adc6click.ad7124.ad7124driver.AD7124Driver.read_status">read_status</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.reset" href="#adc6click.ad7124.ad7124driver.AD7124Driver.reset">reset</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.set_adc_control" href="#adc6click.ad7124.ad7124driver.AD7124Driver.set_adc_control">set_adc_control</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.set_channel" href="#adc6click.ad7124.ad7124driver.AD7124Driver.set_channel">set_channel</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_config" href="#adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_config">set_setup_config</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_filter" href="#adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_filter">set_setup_filter</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_gain" href="#adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_gain">set_setup_gain</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_offset" href="#adc6click.ad7124.ad7124driver.AD7124Driver.set_setup_offset">set_setup_offset</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.to_temperature" href="#adc6click.ad7124.ad7124driver.AD7124Driver.to_temperature">to_temperature</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.to_voltage" href="#adc6click.ad7124.ad7124driver.AD7124Driver.to_voltage">to_voltage</a></code></li>
<li><code><a title="adc6click.ad7124.ad7124driver.AD7124Driver.write_register" href="#adc6click.ad7124.ad7124driver.AD7124Driver.write_register">write_register</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>